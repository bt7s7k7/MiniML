import { escapeRegex } from "../comTypes/util"
import { MmlParser } from "../miniML/MmlParser"
import { SyntaxNode } from "../miniML/SyntaxNode"

export interface HtmlInputShortcut {
    start: string | RegExp
    end: string | RegExp
    object?: string | null
    prefix?: string | null
    suffix?: string | null
}

export class HtmlImporter {
    public shortcuts: HtmlInputShortcut[] = [
        { start: "$$EMBED{{", end: "}}$$" },
        { start: "$$NOTE{{", end: "}}$$", object: "__discard__" },
    ]

    protected readonly _embedParser: HtmlImporter.InlineCssParser

    public forceTableHeader: boolean

    public get widgets() { return this._embedParser.widgets }
    public set widgets(value) { this._embedParser.widgets = value }

    public importStyle<T extends SyntaxNode.NodeWithStyle = SyntaxNode.Span>(element: HTMLElement, container: T | null) {
        const styleAttribute = element.getAttribute("style")
        if (styleAttribute) {
            return this._embedParser.clone(styleAttribute).parseInlineCss(container)
        }

        return container
    }

    public importContent(children: NodeListOf<Node>, container: SyntaxNode.NodeWithChildren) {
        for (const childNode of children) {
            const child = this.importNode(childNode)
            if (child == null) continue
            container.content.push(child)
        }

        this.normalizeContent(container.content, 0)
    }

    public normalizeContent(content: SyntaxNode[], start: number) {
        for (let i = start; i < content.length; i++) {
            const curr = content[i]
            if (i < content.length - 1) {
                const next = content[i + 1]

                // Handle lists generated by Google Docs
                if (curr.kind == "segment" && (curr.type == "ul" || curr.type == "ol") && next.kind == "segment" && next.type == curr.type) {
                    if (curr.content.length > 0 && next.content.length > 0) {
                        const currMargin = curr.content[0].getMetadata(HtmlImporter.META_MARGIN_LEFT)
                        const nextMargin = next.content[0].getMetadata(HtmlImporter.META_MARGIN_LEFT)
                        if (currMargin != null && nextMargin != null) {
                            if (currMargin == nextMargin - 36) {
                                this.normalizeContent(content, i + 1)
                                const last = curr.content.at(-1)
                                if (last && last.kind == "segment" && last.type == "li") {
                                    last.content.push(content[i + 1])
                                } else {
                                    curr.content.push(new SyntaxNode.Segment({ type: "li", content: [content[i + 1]] }))
                                }
                                content.splice(i + 1, 1)
                                i--
                                continue
                            } else if (currMargin == nextMargin) {
                                this.normalizeContent(content, i + 1)
                                curr.content.push(...next.content)
                                content.splice(i + 1, 1)
                                i--
                                continue
                            }
                        }
                    }
                }
            }
        }
    }

    public importTable(tableElement: HTMLElement): SyntaxNode | null {
        const table = SyntaxNode.Table.default()
        this.importTableRows(tableElement, table, false)
        return table
    }

    public importTableRows(container: HTMLElement, table: SyntaxNode.Table, header: boolean) {
        for (const child of container.childNodes) {
            if (!(child instanceof HTMLElement)) continue

            if (child.tagName == "TBODY") {
                this.importTableRows(child, table, false)
                continue
            }

            if (child.tagName == "THEAD") {
                this.importTableRows(child, table, true)
                continue
            }

            if (child.tagName == "TR") {
                const row = SyntaxNode.TableRow.default()
                row.header = header
                table.content.push(row)

                for (const columnElement of child.childNodes) {
                    if (!(columnElement instanceof HTMLElement) || columnElement.tagName != "TD") continue
                    const column = this.importElement(columnElement)
                    if (column != null) {
                        row.content.push(column)
                    }
                }

                continue
            }
        }
    }

    public importElement(element: HTMLElement): SyntaxNode | null {
        let syntax: SyntaxNode.NodeWithStyle | null = null

        if (element.tagName == "B" || element.tagName == "STRONG") {
            syntax = new SyntaxNode.Span({ modifier: "bold", content: [] })
        } else if (element.tagName == "I" || element.tagName == "EM") {
            syntax = new SyntaxNode.Span({ modifier: "italics", content: [] })
        } else if (element.tagName == "CODE" || element.tagName == "CODE") {
            syntax = new SyntaxNode.Span({ modifier: "italics", content: [] })
        } else if (element.tagName == "UL") {
            syntax = new SyntaxNode.Segment({ type: "ul", content: [] })
        } else if (element.tagName == "LI") {
            syntax = new SyntaxNode.Segment({ type: "li", content: [] })
        } else if (element.tagName == "OL") {
            syntax = new SyntaxNode.Segment({ type: "ol", content: [] })
        } else if (element.tagName == "H1") {
            syntax = new SyntaxNode.Segment({ type: 1, content: [] })
        } else if (element.tagName == "H2") {
            syntax = new SyntaxNode.Segment({ type: 2, content: [] })
        } else if (element.tagName == "H3") {
            syntax = new SyntaxNode.Segment({ type: 3, content: [] })
        } else if (element.tagName == "H4") {
            syntax = new SyntaxNode.Segment({ type: 4, content: [] })
        } else if (element.tagName == "DIV") {
            syntax = new SyntaxNode.Segment({ content: [] })
        } else if (element.tagName == "P") {
            syntax = new SyntaxNode.Segment({ type: "p", content: [] })
        } else if (element.tagName == "IMG") {
            syntax = new SyntaxNode.Object({ type: "media", value: (element as HTMLImageElement).src, content: [] })
        } else if (element.tagName == "A") {
            syntax = new SyntaxNode.Object({ type: "link", value: (element as HTMLAnchorElement).href, content: [] })
        } else if (element.tagName == "TABLE") {
            return this.importTable(element)
        } else if (element.tagName == "BR") {
            return new SyntaxNode.Text({ value: "\n" })
        }

        syntax = this.importStyle(element, syntax)

        const children = element.childNodes
        if (children.length == 0) return syntax

        if (syntax == null && children.length == 1) {
            return this.importNode(children[0])
        }

        syntax ??= new SyntaxNode.Span({ content: [] })
        this.importContent(children, syntax)

        return syntax
    }

    public importTextNode(node: Text) {
        let text = node.textContent
        if (text == null) return null

        text = text
            .replace(/\t/g, " ")
            .replace(/(?<=\r?\n) +| +(?=\r?\n)/g, "")
            .replace(/\n|\r/g, " ")
            .replace(/ {2,}/g, " ")

        if (text == "") return null

        return new SyntaxNode.Text({ value: text })
    }

    public importNode(node: Node): SyntaxNode | null {
        if (node instanceof Text) {
            return this.importTextNode(node)
        }

        if (node instanceof HTMLElement) {
            return this.importElement(node)
        }

        if (node instanceof Comment) {
            const content = node.textContent
            if (content == null) return null

            for (const { regexp, shortcut } of this._shortcutMatches) {
                const match = content.match(regexp)

                if (match) {
                    if (shortcut.object == "__discard__") break

                    const embedContent = match[1]
                    const parsedEmbed = document.createElement("template")
                    parsedEmbed.innerHTML = embedContent
                    let embedSource = this.flattenIntoText(parsedEmbed.content)

                    if (shortcut.object) {
                        embedSource = `<${shortcut.object}>${embedSource}</${shortcut.object}>`
                    }

                    if (shortcut.prefix != null) {
                        embedSource = shortcut.prefix + embedSource
                    }

                    if (shortcut.suffix != null) {
                        embedSource = shortcut.suffix + embedSource
                    }

                    const mml = this._embedParser.clone(embedSource)
                    if (embedSource.includes("\n")) {
                        return mml.parseDocument()
                    } else {
                        const result = new SyntaxNode.Span({ content: [] })
                        mml.parseFragment(null, result.content)
                        return result
                    }
                }
            }
        }

        return null
    }

    public flattenIntoText(node: Node) {
        const result: string[] = []
        this.flattenNode(node, result)
        return result.join("")
    }

    public flattenNode(node: Node, result: string[]) {
        if (node instanceof Text) {
            result.push(node.textContent ?? "")
        } else if (node instanceof HTMLElement || node instanceof DocumentFragment) {
            if (node instanceof HTMLElement) {
                if (node.tagName == "BR") {
                    result.push("\n")
                    return
                }
            }

            for (const child of node.childNodes) {
                this.flattenNode(child, result)
            }
        }
    }

    public importDocument(element: HTMLElement | DocumentFragment) {
        const rootSegment = new SyntaxNode.Segment({ content: [] })
        const children = element.childNodes

        this.importContent(children, rootSegment)

        return rootSegment
    }

    protected _shortcutMatches: { regexp: RegExp, shortcut: HtmlInputShortcut }[] = []

    public importHtml(html: string) {
        const template = document.createElement("template")

        if (this.shortcuts.length > 0) {
            const startRegex = new RegExp(`(${this.shortcuts.map(v => typeof v.start == "string" ? escapeRegex(v.start) : `(?:${v.start.source})`).join("|")})`, "g")
            const endRegex = new RegExp(`(${this.shortcuts.map(v => typeof v.end == "string" ? escapeRegex(v.end) : `(?:${v.end.source})`).join("|")})`, "g")

            template.innerHTML = html
                .replace(startRegex, "<!--$1")
                .replace(endRegex, "$1-->")
        } else {
            template.innerHTML = html
        }

        this._shortcutMatches = this.shortcuts.map(shortcut => ({
            regexp: new RegExp(`^(?:${typeof shortcut.start == "string" ? escapeRegex(shortcut.start) : shortcut.start.source
                })((?:.|\\n)*)(?:${typeof shortcut.end == "string" ? escapeRegex(shortcut.end) : shortcut.end.source
                })$`, ""),
            shortcut,
        }))

        const element = template.content
        return this.importDocument(element)
    }

    constructor(
        options?: HtmlImporter.Options,
    ) {
        this._embedParser = new HtmlImporter.InlineCssParser("", options)
        if (options?.shortcuts) {
            this.shortcuts.push(...options.shortcuts)
        }

        this.forceTableHeader = options?.forceTableHeader ?? true
    }
}

export namespace HtmlImporter {
    export const META_MARGIN_LEFT = "META_MARGIN_LEFT" as SyntaxNode.Metadata<number>

    export type Options = MmlParser.Options & { shortcuts?: HtmlInputShortcut[], forceTableHeader?: boolean }

    export class InlineCssParser extends MmlParser {
        protected override _parseInlineCssProperty(name: string, value: string, container: SyntaxNode.NodeWithStyle | null): SyntaxNode.NodeWithStyle | null {
            // Handle lists generated by Google Docs
            if (name == "margin-left") {
                container ??= new SyntaxNode.Span({ content: [] })
                container.setMetadata(META_MARGIN_LEFT, parseInt(value))
                return container
            }

            return super._parseInlineCssProperty(name, value, container)
        }
    }
}
