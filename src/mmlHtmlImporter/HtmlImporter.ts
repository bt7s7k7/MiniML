import { MmlParser } from "../miniML/MmlParser"
import { SyntaxNode } from "../miniML/SyntaxNode"

export class HtmlImporter {
    public importStyle<T extends SyntaxNode.NodeWithStyle = SyntaxNode.Span>(element: HTMLElement, container: T | null) {
        const styleAttribute = element.getAttribute("style")
        if (styleAttribute) {
            return new HtmlImporter.InlineCssParser(styleAttribute).parseInlineCss(container)
        }

        return container
    }

    public importContent(children: NodeListOf<Node>, container: SyntaxNode.NodeWithChildren) {
        for (const childNode of children) {
            const child = this.importNode(childNode)
            if (child == null) continue
            container.content.push(child)
        }

        this.normalizeContent(container.content, 0)
    }

    public normalizeContent(content: SyntaxNode[], start: number) {
        for (let i = start; i < content.length; i++) {
            const curr = content[i]
            if (i < content.length - 1) {
                const next = content[i + 1]

                // Handle lists generated by Google Docs
                if (curr.kind == "segment" && (curr.type == "ul" || curr.type == "ol") && next.kind == "segment" && next.type == curr.type) {
                    if (curr.content.length > 0 && next.content.length > 0) {
                        const currMargin = curr.content[0].getMetadata(HtmlImporter.META_MARGIN_LEFT)
                        const nextMargin = next.content[0].getMetadata(HtmlImporter.META_MARGIN_LEFT)
                        if (currMargin != null && nextMargin != null) {
                            if (currMargin == nextMargin - 36) {
                                this.normalizeContent(content, i + 1)
                                const last = curr.content.at(-1)
                                if (last && last.kind == "segment" && last.type == "li") {
                                    last.content.push(content[i + 1])
                                } else {
                                    curr.content.push(new SyntaxNode.Segment({ type: "li", content: [content[i + 1]] }))
                                }
                                content.splice(i + 1, 1)
                                i--
                                continue
                            } else if (currMargin == nextMargin) {
                                this.normalizeContent(content, i + 1)
                                curr.content.push(...next.content)
                                content.splice(i + 1, 1)
                                i--
                                continue
                            }
                        }
                    }
                }
            }
        }
    }

    public importElement(element: HTMLElement): SyntaxNode | null {
        let syntax: SyntaxNode.NodeWithStyle | null = null

        if (element.tagName == "B" || element.tagName == "STRONG") {
            syntax = new SyntaxNode.Span({ modifier: "bold", content: [] })
        } else if (element.tagName == "I" || element.tagName == "EM") {
            syntax = new SyntaxNode.Span({ modifier: "italics", content: [] })
        } else if (element.tagName == "CODE" || element.tagName == "CODE") {
            syntax = new SyntaxNode.Span({ modifier: "italics", content: [] })
        } else if (element.tagName == "UL") {
            syntax = new SyntaxNode.Segment({ type: "ul", content: [] })
        } else if (element.tagName == "LI") {
            syntax = new SyntaxNode.Segment({ type: "li", content: [] })
        } else if (element.tagName == "OL") {
            syntax = new SyntaxNode.Segment({ type: "ol", content: [] })
        } else if (element.tagName == "H1") {
            syntax = new SyntaxNode.Segment({ type: 1, content: [] })
        } else if (element.tagName == "H2") {
            syntax = new SyntaxNode.Segment({ type: 2, content: [] })
        } else if (element.tagName == "H3") {
            syntax = new SyntaxNode.Segment({ type: 3, content: [] })
        } else if (element.tagName == "H4") {
            syntax = new SyntaxNode.Segment({ type: 4, content: [] })
        } else if (element.tagName == "DIV") {
            syntax = new SyntaxNode.Segment({ content: [] })
        } else if (element.tagName == "P") {
            syntax = new SyntaxNode.Segment({ type: "p", content: [] })
        } else if (element.tagName == "IMG") {
            syntax = new SyntaxNode.Object({ media: true, url: (element as HTMLImageElement).src, content: [] })
        } else if (element.tagName == "A") {
            syntax = new SyntaxNode.Object({ url: (element as HTMLAnchorElement).href, content: [] })
        } else if (element.tagName == "BR") {
            return new SyntaxNode.Text({ value: "\n" })
        }

        syntax = this.importStyle(element, syntax)

        const children = element.childNodes
        if (children.length == 0) return syntax

        if (syntax == null && children.length == 1) {
            return this.importNode(children[0])
        }

        syntax ??= new SyntaxNode.Span({ content: [] })
        this.importContent(children, syntax)

        return syntax
    }

    public importTextNode(node: Text) {
        let text = node.textContent
        if (text == null) return null
        text = text.trim()
        if (text == "") return null

        return new SyntaxNode.Text({ value: text })
    }

    public importNode(node: Node): SyntaxNode | null {
        if (node instanceof Text) {
            return this.importTextNode(node)
        }

        if (node instanceof HTMLElement) {
            return this.importElement(node)
        }

        if (node instanceof Comment) {
            const content = node.textContent
            if (content == null) return null
            if (content.startsWith("$$EMBED{{") && content.endsWith("}}$$")) {
                const embedContent = content.slice(9, -4)
                const parsedEmbed = document.createElement("template")
                parsedEmbed.innerHTML = embedContent
                const embedSource = this.flattenIntoText(parsedEmbed.content)
                const mml = new MmlParser(embedSource)
                if (embedSource.includes("\n")) {
                    return mml.parseDocument()
                } else {
                    const result = new SyntaxNode.Span({ content: [] })
                    mml.parseFragment(null, result.content)
                    return result
                }
            }
        }

        return null
    }

    public flattenIntoText(node: Node) {
        const result: string[] = []
        this.flattenNode(node, result)
        return result.join("")
    }

    public flattenNode(node: Node, result: string[]) {
        if (node instanceof Text) {
            result.push(node.textContent ?? "")
        } else if (node instanceof HTMLElement || node instanceof DocumentFragment) {
            if (node instanceof HTMLElement) {
                if (node.tagName == "BR") {
                    result.push("\n")
                    return
                }
            }

            for (const child of node.childNodes) {
                this.flattenNode(child, result)
            }
        }
    }

    public importDocument(element: HTMLElement | DocumentFragment) {
        const rootSegment = new SyntaxNode.Segment({ content: [] })
        const children = element.childNodes

        this.importContent(children, rootSegment)

        return rootSegment
    }

    public importHtml(html: string) {
        const template = document.createElement("template")
        template.innerHTML = html
            .replace(/(\$\$EMBED{{)/g, "<!--$1")
            .replace(/(}}\$\$)/g, "$1-->")
        const element = template.content
        return this.importDocument(element)
    }
}

export namespace HtmlImporter {
    export const META_MARGIN_LEFT = "META_MARGIN_LEFT" as SyntaxNode.Metadata<number>

    export class InlineCssParser extends MmlParser {
        protected override _parseInlineCssProperty(name: string, value: string, container: SyntaxNode.NodeWithStyle | null): SyntaxNode.NodeWithStyle | null {
            // Handle lists generated by Google Docs
            if (name == "margin-left") {
                container ??= new SyntaxNode.Span({ content: [] })
                container.setMetadata(META_MARGIN_LEFT, parseInt(value))
                return container
            }

            return super._parseInlineCssProperty(name, value, container)
        }
    }
}
